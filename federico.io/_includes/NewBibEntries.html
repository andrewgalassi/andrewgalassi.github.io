<!DOCTYPE HTML>
<html>
<head>
<title>JabRef references</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<script type="text/javascript">
<!--
// QuickSearch script for JabRef HTML export 
// Version: 3.0
//
// Copyright (c) 2006-2011, Mark Schenk
//
// This software is distributed under a Creative Commons Attribution 3.0 License
// http://creativecommons.org/licenses/by/3.0/
//
// Features:
// - intuitive find-as-you-type searching
//    ~ case insensitive
//    ~ ignore diacritics (optional)
//
// - search with/without Regular Expressions
// - match BibTeX key
//

// Search settings
var searchAbstract = true;	// search in abstract
var searchReview = true;	// search in review

var noSquiggles = true; 	// ignore diacritics when searching
var searchRegExp = false; 	// enable RegExp searches


if (window.addEventListener) {
	window.addEventListener("load",initSearch,false); }
else if (window.attachEvent) {
	window.attachEvent("onload", initSearch); }

function initSearch() {
	// check for quick search table and searchfield
	if (!document.getElementById('qs_table')||!document.getElementById('quicksearch')) { return; }

	// load all the rows and sort into arrays
	loadTableData();
	
	//find the query field
	qsfield = document.getElementById('qs_field');

	// previous search term; used for speed optimisation
	prevSearch = '';

	//find statistics location
	stats = document.getElementById('stat');
	setStatistics(-1);
	
	// set up preferences
	initPreferences();

	// shows the searchfield
	document.getElementById('quicksearch').style.display = 'block';
	document.getElementById('qs_field').onkeyup = quickSearch;
}

function loadTableData() {
	// find table and appropriate rows
	searchTable = document.getElementById('qs_table');
	var allRows = searchTable.getElementsByTagName('tbody')[0].getElementsByTagName('tr');

	// split all rows into entryRows and infoRows (e.g. abstract, review, bibtex)
	entryRows = new Array(); infoRows = new Array(); absRows = new Array(); revRows = new Array();

	// get data from each row
	entryRowsData = new Array(); absRowsData = new Array(); revRowsData = new Array(); 
	
	BibTeXKeys = new Array();
	
	for (var i=0, k=0, j=0; i<allRows.length;i++) {
		if (allRows[i].className.match(/entry/)) {
			entryRows[j] = allRows[i];
			entryRowsData[j] = stripDiacritics(getTextContent(allRows[i]));
			allRows[i].id ? BibTeXKeys[j] = allRows[i].id : allRows[i].id = 'autokey_'+j;
			j ++;
		} else {
			infoRows[k++] = allRows[i];
			// check for abstract/review
			if (allRows[i].className.match(/abstract/)) {
				absRows.push(allRows[i]);
				absRowsData[j-1] = stripDiacritics(getTextContent(allRows[i]));
			} else if (allRows[i].className.match(/review/)) {
				revRows.push(allRows[i]);
				revRowsData[j-1] = stripDiacritics(getTextContent(allRows[i]));
			}
		}
	}
	//number of entries and rows
	numEntries = entryRows.length;
	numInfo = infoRows.length;
	numAbs = absRows.length;
	numRev = revRows.length;
}

function quickSearch(){
	
	tInput = qsfield;

	if (tInput.value.length == 0) {
		showAll();
		setStatistics(-1);
		qsfield.className = '';
		return;
	} else {
		t = stripDiacritics(tInput.value);

		if(!searchRegExp) { t = escapeRegExp(t); }
			
		// only search for valid RegExp
		try {
			textRegExp = new RegExp(t,"i");
			closeAllInfo();
			qsfield.className = '';
		}
			catch(err) {
			prevSearch = tInput.value;
			qsfield.className = 'invalidsearch';
			return;
		}
	}
	
	// count number of hits
	var hits = 0;

	// start looping through all entry rows
	for (var i = 0; cRow = entryRows[i]; i++){

		// only show search the cells if it isn't already hidden OR if the search term is getting shorter, then search all
		if(cRow.className.indexOf('noshow')==-1 || tInput.value.length <= prevSearch.length){
			var found = false; 

			if (entryRowsData[i].search(textRegExp) != -1 || BibTeXKeys[i].search(textRegExp) != -1){ 
				found = true;
			} else {
				if(searchAbstract && absRowsData[i]!=undefined) {
					if (absRowsData[i].search(textRegExp) != -1){ found=true; } 
				}
				if(searchReview && revRowsData[i]!=undefined) {
					if (revRowsData[i].search(textRegExp) != -1){ found=true; } 
				}
			}
			
			if (found){
				cRow.className = 'entry show';
				hits++;
			} else {
				cRow.className = 'entry noshow';
			}
		}
	}

	// update statistics
	setStatistics(hits)
	
	// set previous search value
	prevSearch = tInput.value;
}


// Strip Diacritics from text
// http://stackoverflow.com/questions/990904/javascript-remove-accents-in-strings

// String containing replacement characters for stripping accents 
var stripstring = 
    'AAAAAAACEEEEIIII'+
    'DNOOOOO.OUUUUY..'+
    'aaaaaaaceeeeiiii'+
    'dnooooo.ouuuuy.y'+
    'AaAaAaCcCcCcCcDd'+
    'DdEeEeEeEeEeGgGg'+
    'GgGgHhHhIiIiIiIi'+
    'IiIiJjKkkLlLlLlL'+
    'lJlNnNnNnnNnOoOo'+
    'OoOoRrRrRrSsSsSs'+
    'SsTtTtTtUuUuUuUu'+
    'UuUuWwYyYZzZzZz.';

function stripDiacritics(str){

    if(noSquiggles==false){
        return str;
    }

    var answer='';
    for(var i=0;i<str.length;i++){
        var ch=str[i];
        var chindex=ch.charCodeAt(0)-192;   // Index of character code in the strip string
        if(chindex>=0 && chindex<stripstring.length){
            // Character is within our table, so we can strip the accent...
            var outch=stripstring.charAt(chindex);
            // ...unless it was shown as a '.'
            if(outch!='.')ch=outch;
        }
        answer+=ch;
    }
    return answer;
}

// http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
// NOTE: must escape every \ in the export code because of the JabRef Export...
function escapeRegExp(str) {
  return str.replace(/[-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

function toggleInfo(articleid,info) {

	var entry = document.getElementById(articleid);
	var abs = document.getElementById('abs_'+articleid);
	var rev = document.getElementById('rev_'+articleid);
	var bib = document.getElementById('bib_'+articleid);
	
	if (abs && info == 'abstract') {
		abs.className.indexOf('noshow') == -1?abs.className = 'abstract noshow':abs.className = 'abstract show';
	} else if (rev && info == 'review') {
		rev.className.indexOf('noshow') == -1?rev.className = 'review noshow':rev.className = 'review show';
	} else if (bib && info == 'bibtex') {
		bib.className.indexOf('noshow') == -1?bib.className = 'bibtex noshow':bib.className = 'bibtex show';
	} else { 
		return;
	}

	// check if one or the other is available
	var revshow; var absshow; var bibshow;
	(abs && abs.className.indexOf('noshow') == -1)? absshow = true: absshow = false;
	(rev && rev.className.indexOf('noshow') == -1)? revshow = true: revshow = false;	
	(bib && bib.className.indexOf('noshow') == -1)? bibshow = true: bibshow = false;
	
	// highlight original entry
	if(entry) {
		if (revshow || absshow || bibshow) {
		entry.className = 'entry highlight show';
		} else {
		entry.className = 'entry show';
		}
	}
	
	// When there's a combination of abstract/review/bibtex showing, need to add class for correct styling
	if(absshow) {
		(revshow||bibshow)?abs.className = 'abstract nextshow':abs.className = 'abstract';
	} 
	if (revshow) {
		bibshow?rev.className = 'review nextshow': rev.className = 'review';
	}	
	
}

function setStatistics (hits) {
	if(hits < 0) { hits=numEntries; }
	if(stats) { stats.firstChild.data = hits + '/' + numEntries}
}

function getTextContent(node) {
	// Function written by Arve Bersvendsen
	// http://www.virtuelvis.com
	
	if (node.nodeType == 3) {
	return node.nodeValue;
	} // text node
	if (node.nodeType == 1 && node.className != "infolinks") { // element node
	var text = [];
	for (var chld = node.firstChild;chld;chld=chld.nextSibling) {
		text.push(getTextContent(chld));
	}
	return text.join("");
	} return ""; // some other node, won't contain text nodes.
}

function showAll(){
	closeAllInfo();
	for (var i = 0; i < numEntries; i++){ entryRows[i].className = 'entry show'; }
}

function closeAllInfo(){
	for (var i=0; i < numInfo; i++){
		if (infoRows[i].className.indexOf('noshow') ==-1) {
			infoRows[i].className = infoRows[i].className + ' noshow';
		}
	}
}

function clearQS() {
	qsfield.value = '';
	showAll();
}

function redoQS(){
	showAll();
	quickSearch(qsfield);
}

function updateSetting(obj){
	var option = obj.id;
	var checked = obj.value;

	switch(option)
	 {
	 case "opt_searchAbs":
	   searchAbstract=!searchAbstract;
	   redoQS();
	   break;
	 case "opt_searchRev":
	   searchReview=!searchReview;
	   redoQS();
	   break;
	 case "opt_useRegExp":
	   searchRegExp=!searchRegExp;
	   redoQS();
	   break;
	 case "opt_noAccents":
	   noSquiggles=!noSquiggles;
	   loadTableData();
	   redoQS();
	   break;
	 }
}

function initPreferences(){
	if(searchAbstract){document.getElementById("opt_searchAbs").checked = true;}
	if(searchReview){document.getElementById("opt_searchRev").checked = true;}
	if(noSquiggles){document.getElementById("opt_noAccents").checked = true;}
	if(searchRegExp){document.getElementById("opt_useRegExp").checked = true;}
	
	if(numAbs==0) {document.getElementById("opt_searchAbs").parentNode.style.display = 'none';}
	if(numRev==0) {document.getElementById("opt_searchRev").parentNode.style.display = 'none';}	
}

function toggleSettings(){
	var togglebutton = document.getElementById('showsettings');
	var settings = document.getElementById('settings');
	
	if(settings.className == "hidden"){
		settings.className = "show";
		togglebutton.innerText = "close settings";
		togglebutton.textContent = "close settings";
	}else{
		settings.className = "hidden";
		togglebutton.innerText = "settings...";		
		togglebutton.textContent = "settings...";
	}
}

-->
</script>
<style type="text/css">
body { background-color: white; font-family: Arial, sans-serif; font-size: 13px; line-height: 1.2; padding: 1em; color: #2E2E2E; width: 50em; margin: auto auto; }

form#quicksearch { width: auto; border-style: solid; border-color: gray; border-width: 1px 0px; padding: 0.7em 0.5em; display:none; position:relative; }
span#searchstat {padding-left: 1em;}

div#settings { margin-top:0.7em; /* border-bottom: 1px transparent solid; background-color: #efefef; border: 1px grey solid; */ }
div#settings ul {margin: 0; padding: 0; }
div#settings li {margin: 0; padding: 0 1em 0 0; display: inline; list-style: none; }
div#settings li + li { border-left: 2px #efefef solid; padding-left: 0.5em;}
div#settings input { margin-bottom: 0px;}

div#settings.hidden {display:none;}

#showsettings { border: 1px grey solid; padding: 0 0.5em; float:right; line-height: 1.6em; text-align: right; }
#showsettings:hover { cursor: pointer; }

.invalidsearch { background-color: red; }
input[type="button"] { background-color: #efefef; border: 1px #2E2E2E solid;}

table { border: 1px gray none; width: 100%; empty-cells: show; border-spacing: 0em 0.1em; margin: 1em 0em; }
th, td { border: none; padding: 0.5em; vertical-align: top; text-align: justify; }

td a { color: navy; text-decoration: none; }
td a:hover  { text-decoration: underline; }

tr.noshow { display: none;}
tr.highlight td { background-color: #EFEFEF; border-top: 2px #2E2E2E solid; font-weight: bold; }
tr.abstract td, tr.review td, tr.bibtex td { background-color: #EFEFEF; text-align: justify; border-bottom: 2px #2E2E2E solid; }
tr.nextshow td { border-bottom-style: none; }

tr.bibtex pre { width: 100%; overflow: auto; white-space: pre-wrap;}
p.infolinks { margin: 0.3em 0em 0em 0em; padding: 0px; }

@media print {
	p.infolinks, #qs_settings, #quicksearch, t.bibtex { display: none !important; }
	tr { page-break-inside: avoid; }
}
</style>
</head>
<body>

<form action="" id="quicksearch">
<input type="text" id="qs_field" autocomplete="off" placeholder="Type to search..." /> <input type="button" onclick="clearQS()" value="clear" />
<span id="searchstat">Matching entries: <span id="stat">0</span></span>
<div id="showsettings" onclick="toggleSettings()">settings...</div>
<div id="settings" class="hidden">
<ul>
<li><input type="checkbox" class="search_setting" id="opt_searchAbs" onchange="updateSetting(this)"><label for="opt_searchAbs"> include abstract</label></li>
<li><input type="checkbox" class="search_setting" id="opt_searchRev" onchange="updateSetting(this)"><label for="opt_searchRev"> include review</label></li>
<li><input type="checkbox" class="search_setting" id="opt_useRegExp" onchange="updateSetting(this)"><label for="opt_useRegExp"> use RegExp</label></li>
<li><input type="checkbox" class="search_setting" id="opt_noAccents" onchange="updateSetting(this)"><label for="opt_noAccents"> ignore accents</label></li>
</ul>
</div>
</form>
<table id="qs_table" border="1">
<tbody>
<tr id="RI-FR-RZ-MP:16" class="entry">
	<td>Iglesias R, Rossi F, Zhang R and Pavone M (2016), <i>"A BCMP Network Approach to Modeling and Controlling Autonomous Mobility-on-Demand Systems"</i>, In Workshop on Algorithmic Foundations of Robotics. San Francisco, CA, December, 2016. 
	<p class="infolinks">[<a href="javascript:toggleInfo('RI-FR-RZ-MP:16','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('RI-FR-RZ-MP:16','bibtex')">BibTeX</a>] [<a href="http://arxiv.org/abs/1607.04357" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_RI-FR-RZ-MP:16" class="abstract noshow">
	<td><b>Abstract</b>: In this paper, we present a queueing network approach to the problem of routing and rebalancing a fleet of self-driving vehicles providing on-demand mobility within a capacitated road network. We refer to such systems as autonomous mobility-on-demand systems, or AMoD. We first cast an AMoD system into a closed, multi-class BCMP queueing network model. Second, we present analysis tools that allow the characterization of performance metrics for a given routing policy, in terms, e.g., of vehicle availabilities and second-order moments of vehicle throughput. Third, we propose a scalable method for the synthesis of routing policies, with performance guarantees in the limit of large fleet sizes. Finally, we validate our theoretical results on a case study of New York City. Collectively, this paper provides a unifying framework for the analysis and control of AMoD systems, which subsumes earlier Jackson and flow network models, provides a quite large set of modeling options (e.g., the inclusion of road capacities and general travel time distributions), and allows the analysis of second and higher-order moments for the performance metrics.</td>
</tr>
<tr id="bib_RI-FR-RZ-MP:16" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{RI-FR-RZ-MP:16,
  author = {Iglesias, Ramon and Rossi, Federico and Zhang, Rick and Pavone, Marco},
  title = {A BCMP Network Approach to Modeling and Controlling Autonomous Mobility-on-Demand Systems},
  booktitle = {Workshop on Algorithmic Foundations of Robotics},
  year = {2016},
  note = {In press},
  url = {http://arxiv.org/abs/1607.04357}
}
</pre></td>
</tr>
<tr id="FR-MP:13" class="entry">
	<td>Rossi F and Pavone M (2013), <i>"Decentralized Decision-making on Robotic Networks with Hybrid Performance Metrics"</i>, In Allerton Conf. on Communications, Control and Computing., October, 2013. , pp. 358-365.
	<p class="infolinks">[<a href="javascript:toggleInfo('FR-MP:13','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('FR-MP:13','bibtex')">BibTeX</a>] [<a href="http://doi.org/10.1109/allerton.2013.6736546" target="_blank">DOI</a>] [<a href="../pdf/Rossi.Pavone.Allerton13.pdf" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_FR-MP:13" class="abstract noshow">
	<td><b>Abstract</b>: The past decade has witnessed a rapidly growing interest in decentralized algorithms for collective decision-making in cyber-physical networks. For a large variety of settings, control strategies are now known that either minimize time complexity (i.e., convergence time) or optimize communication complexity (i.e., number and size of exchanged messages). Yet, little attention has beed paid to the problem of studying the inherent trade-off between time and communication complexity. Generally speaking, time-optimal algorithms are fast and robust, but require a large (and sometimes impractical) number of exchanged messages; in contrast, communication optimal algorithms minimize the amount of information routed through the network, but are slow and sensitive to link failures. In this paper we address this gap by focusing on a generalized version of the decentralized consensus problem (that includes voting and mediation) on undirected network topologies and in the presence of "infrequent" link failures. We present and rigorously analyze a tunable, semi-hierarchical algorithm, where the tuning parameter allows a graceful transition from time-optimal to communication-optimal performance (hence, allowing hybrid performance metrics), and determines the algorithm's robustness, measured as the time required to recover from a failure. An interesting feature of our algorithm is that it leads the decision-making agents to self-organize into a semi-hierarchical structure with variable-size clusters, among which information is flooded. Our results make use of a novel connection between the consensus problem and the theory of gamma synchronizers. Simulation experiments are presented and discussed.</td>
</tr>
<tr id="bib_FR-MP:13" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{FR-MP:13,
  author = {Federico Rossi and Marco Pavone},
  title = {Decentralized Decision-making on Robotic Networks with Hybrid Performance Metrics},
  booktitle = {Allerton Conf. on Communications, Control and Computing},
  year = {2013},
  pages = {358-365},
  url = {../pdf/Rossi.Pavone.Allerton13.pdf},
  doi = {10.1109/allerton.2013.6736546}
}
</pre></td>
</tr>
<tr id="FR-MP:14a" class="entry">
	<td>Rossi F and Pavone M (2014), <i>"On the Fundamental Limitations of Performance for Distributed Decision-making in Robotic Networks"</i>, In Proc. IEEE Conf. on Decision and Control. Los Angeles, CA, December, 2014. , pp. 2433-2440.
	<p class="infolinks">[<a href="javascript:toggleInfo('FR-MP:14a','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('FR-MP:14a','bibtex')">BibTeX</a>] [<a href="http://doi.org/10.1109/CDC.2014.7039760" target="_blank">DOI</a>] [<a href="http://arxiv.org/pdf/1409.4863" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_FR-MP:14a" class="abstract noshow">
	<td><b>Abstract</b>: This paper studies fundamental limitations of performance for distributed decision-making in robotic networks. The class of decision-making problems we consider encompasses a number of prototypical problems such as average-based consensus as well as distributed optimization, leader election, majority voting, MAX, MIN, and logical formulas. We first propose a formal model for distributed computation on robotic networks that is based on the concept of I/O automata and is inspired by the Computer Science literature on distributed computing clusters. Then, we present a number of bounds on time, message, and byte complexity, which we use to discuss the relative performance of a number of approaches for distributed decision-making. From a methodological standpoint, our work sheds light on the relation between the tools developed by the Computer Science and Controls communities on the topic of distributed algorithms.</td>
</tr>
<tr id="bib_FR-MP:14a" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{FR-MP:14a,
  author = {Rossi, Federico and Pavone, Marco},
  title = {On the Fundamental Limitations of Performance for Distributed Decision-making in Robotic Networks},
  booktitle = {Proc. IEEE Conf. on Decision and Control},
  year = {2014},
  pages = {2433-2440},
  url = {http://arxiv.org/pdf/1409.4863},
  doi = {10.1109/CDC.2014.7039760}
}
</pre></td>
</tr>
<tr id="FR-MP:14b" class="entry">
	<td>Rossi F and Pavone M (2014), <i>"Distributed Consensus with Mixed Time/Communication Bandwidth Performance Metrics"</i>, In Allerton Conf. on Communications, Control and Computing., September, 2014. , pp. 286-293.
	<p class="infolinks">[<a href="javascript:toggleInfo('FR-MP:14b','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('FR-MP:14b','bibtex')">BibTeX</a>] [<a href="http://doi.org/10.1109/ALLERTON.2014.7028468" target="_blank">DOI</a>] [<a href="http://arxiv.org/pdf/1410.0956" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_FR-MP:14b" class="abstract noshow">
	<td><b>Abstract</b>: In this paper we study the inherent trade-off between time and communication complexity for the distributed consensus problem. In our model, communication complexity is measured as the maximum data throughput (in bits per second) sent through the network at a given instant. Such a notion of communication complexity, referred to as bandwidth complexity, is related to the frequency bandwidth a designer should collectively allocate to the agents if they were to communicate via a wireless channel, which represents an important constraint for dense robotic networks. We prove a lower bound on the bandwidth complexity of the consensus problem and provide a consensus algorithm that is bandwidth-optimal for a wide class of consensus functions. We then propose a distributed algorithm that can trade communication complexity versus time complexity as a function of a tunable parameter, which can be adjusted by a system designer as a function of the properties of the wireless communication channel. We rigorously characterize the tunable algorithm's worst-case bandwidth complexity and show that it compares favorably with the bandwidth complexity of well-known consensus algorithm.</td>
</tr>
<tr id="bib_FR-MP:14b" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{FR-MP:14b,
  author = {Rossi, Federico and Pavone, Marco},
  title = {Distributed Consensus with Mixed Time/Communication Bandwidth Performance Metrics},
  booktitle = {Allerton Conf. on Communications, Control and Computing},
  year = {2014},
  pages = {286-293},
  url = {http://arxiv.org/pdf/1410.0956},
  doi = {10.1109/ALLERTON.2014.7028468}
}
</pre></td>
</tr>
<tr id="RZ-FR-MP:16" class="entry">
	<td>Zhang R, Rossi F and Pavone M (2016), <i>"Model Predictive Control of Autonomous Mobility-on-Demand Systems"</i>, In Proc. IEEE Conf. on Robotics and Automation. Stockholm, Sweden, May, 2016. , pp. 1382 - 1389.
	<p class="infolinks">[<a href="javascript:toggleInfo('RZ-FR-MP:16','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('RZ-FR-MP:16','bibtex')">BibTeX</a>] [<a href="http://doi.org/10.1109/ICRA.2016.7487272" target="_blank">DOI</a>] [<a href="http://arxiv.org/abs/1509.03985" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_RZ-FR-MP:16" class="abstract noshow">
	<td><b>Abstract</b>: In this paper we present a model predictive control (MPC) approach to optimize vehicle scheduling and routing in an autonomous mobility-on-demand (AMoD) system. In AMoD systems, robotic, self-driving vehicles transport customers within an urban environment and are coordinated to optimize service throughout the entire network. Specifically, we first propose a novel discrete-time model of an AMoD system and we show that this formulation allows the easy integration of a number of real-world constraints, e.g., electric vehicle charging constraints. Second, leveraging our model, we design a model predictive control algorithm for the optimal coordination of an AMoD system and prove its stability in the sense of Lyapunov. At each optimization step, the vehicle scheduling and routing problem is solved as a mixed integer linear program (MILP) where the decision variables are binary variables representing whether a vehicle will 1) wait at a station, 2) service a customer, or 3) rebalance to another station. Finally, by using real-world data, we show that the MPC algorithm can be run in real-time for moderately-sized systems and outperforms previous control strategies for AMoD systems.<br></td>
</tr>
<tr id="bib_RZ-FR-MP:16" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{RZ-FR-MP:16,
  author = {Zhang, Rick and Rossi, Federico and Pavone, Marco},
  title = {Model Predictive Control of Autonomous Mobility-on-Demand Systems},
  booktitle = {Proc. IEEE Conf. on Robotics and Automation},
  year = {2016},
  pages = {1382 - 1389},
  url = {http://arxiv.org/abs/1509.03985},
  doi = {10.1109/ICRA.2016.7487272}
}
</pre></td>
</tr>
<tr id="RZ-FR-MP:16a" class="entry">
	<td>Zhang R, Rossi F and Pavone M (2016), <i>"Routing Autonomous Vehicles in Congested Transportation Networks: Structural Properties and Coordination Algorithms"</i>, In Robotics: Science and Systems. Ann Arbor, MI, July, 2016. 
	<p class="infolinks">[<a href="javascript:toggleInfo('RZ-FR-MP:16a','abstract')">Abstract</a>] [<a href="javascript:toggleInfo('RZ-FR-MP:16a','bibtex')">BibTeX</a>] [<a href="http://doi.org/10.15607/rss.2016.xii.032" target="_blank">DOI</a>] [<a href="http://arxiv.org/abs/1603.00939" target="_blank">URL</a>]</p>
	</td>
</tr>
<tr id="abs_RZ-FR-MP:16a" class="abstract noshow">
	<td><b>Abstract</b>: This paper considers the problem of routing and rebalancing a shared fleet of autonomous (i.e., self-driving) vehicles providing on-demand mobility within a capacitated transportation network, where congestion might disrupt throughput. We model the problem within a network flow framework and show that under relatively mild assumptions the rebalancing vehicles, if properly coordinated, do not lead to an increase in congestion (in stark contrast to common belief). From an algorithmic standpoint, such theoretical insight suggests that the problem of routing customers and rebalancing vehicles can be decoupled, which leads to a computationally-efficient routing and rebalancing algorithm for the autonomous vehicles. Numerical experiments and case studies corroborate our theoretical insights and show that the proposed algorithm outperforms state-of-the-art point-to-point methods by avoiding excess congestion on the road. Collectively, this paper provides a rigorous approach to the problem of congestion-aware, system-wide coordination of autonomously driving vehicles, and to the characterization of the sustainability of such robotic systems.</td>
</tr>
<tr id="bib_RZ-FR-MP:16a" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{RZ-FR-MP:16a,
  author = {Zhang, Rick and Rossi, Federico and Pavone, Marco},
  title = {Routing Autonomous Vehicles in Congested Transportation Networks: Structural Properties and Coordination Algorithms},
  booktitle = {Robotics: Science and Systems},
  year = {2016},
  url = {http://arxiv.org/abs/1603.00939},
  doi = {10.15607/rss.2016.xii.032}
}
</pre></td>
</tr>
</tbody>
</table>
<footer>
 <small>Created by <a href="http://jabref.sourceforge.net">JabRef</a> on 03/11/2016.</small>
</footer>
<!-- file generated by JabRef -->
</body>
</html>